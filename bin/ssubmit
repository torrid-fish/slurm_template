#!/usr/bin/env python3
import sys
import os
import re
import json
import shlex
import subprocess
from dataclasses import dataclass, asdict, field
from datetime import datetime
from typing import Dict, List, Optional, Any, Tuple

# --- SLURM Parser Logic ---


@dataclass
class SbatchOptions:
    """Parsed SLURM sbatch options."""

    nodes: Optional[int] = None
    ntasks: Optional[int] = None
    cpus_per_task: Optional[int] = None
    gres: Optional[str] = None
    time: Optional[str] = None
    partition: Optional[str] = None
    job_name: Optional[str] = None
    output: Optional[str] = None
    error: Optional[str] = None
    mem: Optional[str] = None
    mem_per_cpu: Optional[str] = None
    mail_type: Optional[str] = None
    mail_user: Optional[str] = None
    dependency: Optional[str] = None
    array: Optional[str] = None
    exclusive: Optional[str] = None
    constraint: Optional[str] = None
    account: Optional[str] = None
    extra_options: Dict[str, Any] = field(default_factory=dict)

    def to_sbatch_args(self) -> List[str]:
        mapping = {
            "nodes": ("--nodes", "="),
            "ntasks": ("--ntasks", "="),
            "cpus_per_task": ("--cpus-per-task", "="),
            "gres": ("--gres", "="),
            "time": ("--time", "="),
            "partition": ("--partition", "="),
            "job_name": ("--job-name", "="),
            "output": ("--output", "="),
            "error": ("--error", "="),
            "mem": ("--mem", "="),
            "mem_per_cpu": ("--mem-per-cpu", "="),
            "mail_type": ("--mail-type", "="),
            "mail_user": ("--mail-user", "="),
            "dependency": ("--dependency", "="),
            "array": ("--array", "="),
            "exclusive": ("--exclusive", "="),
            "constraint": ("--constraint", "="),
            "account": ("--account", "="),
        }
        args = []
        for attr, (flag, sep) in mapping.items():
            val = getattr(self, attr)
            if val is not None:
                args.append(f"{flag}{sep}{val}")
        for key, val in self.extra_options.items():
            if val is True:
                args.append(f"--{key}")
            elif val is not False:
                args.append(f"--{key}={val}")
        return args


class SbatchParser:
    OPTION_ALIASES = {
        "-N": "nodes",
        "--nodes": "nodes",
        "-n": "ntasks",
        "--ntasks": "ntasks",
        "-c": "cpus_per_task",
        "--cpus-per-task": "cpus_per_task",
        "--gres": "gres",
        "--time": "time",
        "-p": "partition",
        "--partition": "partition",
        "-J": "job_name",
        "--job-name": "job_name",
        "-o": "output",
        "--output": "output",
        "-e": "error",
        "--error": "error",
        "--mem": "mem",
        "--mem-per-cpu": "mem_per_cpu",
        "--mail-type": "mail_type",
        "--mail-user": "mail_user",
        "--dependency": "dependency",
        "--array": "array",
        "--exclusive": "exclusive",
        "--constraint": "constraint",
        "-A": "account",
        "--account": "account",
    }

    def __init__(self):
        self.options = SbatchOptions()
        self.errors = []

    def parse(self, args: List[str]) -> Tuple[SbatchOptions, List[str]]:
        i = 0
        while i < len(args):
            arg = args[i]
            if not arg.startswith("-"):
                return self.options, args[i:]
            if arg == "--":
                return self.options, args[i + 1 :]
            if arg in ("-h", "--help"):
                self._print_help()
                sys.exit(0)
            i = self._parse_one(arg, args, i)
        return self.options, []

    def _parse_one(self, arg: str, args: List[str], index: int) -> int:
        if "=" in arg:
            opt, val = arg.split("=", 1)
            self._set(opt, val)
            return index + 1
        canonical = self.OPTION_ALIASES.get(arg)
        if canonical:
            if canonical == "exclusive":
                self._set(arg, True)
                return index + 1
            if index + 1 < len(args) and not args[index + 1].startswith("-"):
                self._set(arg, args[index + 1])
                return index + 2
            self.errors.append(f"Option {arg} requires a value")
            return index + 1
        # Unknown
        opt_name = arg.lstrip("-").replace("-", "_")
        self.options.extra_options[opt_name] = True
        return index + 1

    def _set(self, opt: str, val: Any):
        canonical = self.OPTION_ALIASES.get(opt)
        if not canonical:
            self.options.extra_options[opt.lstrip("-").replace("-", "_")] = val
            return
        try:
            if canonical in ("nodes", "ntasks", "cpus_per_task"):
                setattr(self.options, canonical, int(val))
            elif canonical == "time":
                self._validate_time(val)
                setattr(self.options, canonical, val)
            elif canonical in ("mem", "mem_per_cpu"):
                self._validate_mem(val)
                setattr(self.options, canonical, val)
            else:
                setattr(self.options, canonical, str(val))
        except Exception as e:
            self.errors.append(f"Invalid value for {opt}: {e}")

    def _validate_time(self, s):
        if not (
            re.match(r"^\d+$", s)
            or re.match(r"^\d+-\d{1,2}:\d{2}:\d{2}$", s)
            or re.match(r"^\d{1,2}:\d{2}:\d{2}$", s)
        ):
            self.errors.append(f"Invalid time: {s}")

    def _validate_mem(self, s):
        if not re.match(r"^\d+[KMGT]?$", s, re.I):
            self.errors.append(f"Invalid memory: {s}")

    def _print_help(self):
        print("Usage: ssubmit [OPTIONS] [SLURM_OPTIONS] '<command>'")
        print("Options: --cleanup (Auto-remove worktree)")


# --- Main Logic ---


def run():
    # 1. Parse Args
    args = sys.argv[1:]
    auto_cleanup = "--cleanup" in args
    if auto_cleanup:
        args.remove("--cleanup")

    parser = SbatchParser()
    options, command_args = parser.parse(args)
    if parser.errors:
        for e in parser.errors:
            print(f"Error: {e}", file=sys.stderr)
        sys.exit(1)

    command = " ".join(command_args)
    if not command:
        print("Error: No command provided.")
        sys.exit(1)

    # Resolve SCRIPT path if it's a file
    script_path = command_args[0] if command_args else ""
    if os.path.isfile(script_path):
        script_path = os.path.abspath(script_path)
        command = shlex.join([script_path] + command_args[1:])

    # 2. Git Check
    try:
        subprocess.check_call(
            ["git", "rev-parse", "--is-inside-work-tree"],
            stdout=subprocess.DEVNULL,
            stderr=subprocess.DEVNULL,
        )
    except:
        print("Error: Not a git repository.")
        sys.exit(1)

    if subprocess.check_output(["git", "status", "--porcelain"]):
        print("Error: Dirty worktree. Please commit changes first.")
        sys.exit(1)

    # 3. Setup IDs and Paths
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    git_hash = (
        subprocess.check_output(["git", "rev-parse", "--short", "HEAD"])
        .decode()
        .strip()
    )
    full_id = f"{timestamp}_{git_hash}"

    project_root = os.getcwd()
    snapshot_dir = os.path.expanduser(f"~/snapshots/{full_id}")
    os.makedirs(snapshot_dir, exist_ok=True)

    # 4. Snapshoting
    print(f"Creating snapshot: {full_id}")
    try:
        subprocess.check_call(
            ["git", "worktree", "add", "--detach", "-f", snapshot_dir, "HEAD"],
            stdout=subprocess.DEVNULL,
        )
    except Exception as e:
        print(f"Error creating worktree: {e}")
        sys.exit(1)

    # Soft-links
    for d in ["data", "checkpoints", "output", "wandb", ".venv"]:
        src = os.path.join(project_root, d)
        if os.path.isdir(src):
            dst = os.path.join(snapshot_dir, d)
            os.makedirs(dst, exist_ok=True)
            subprocess.call(["ln", "-s", src, dst])

    # 5. sbatch Options
    log_file = os.path.expanduser(f"~/log/{full_id}.out")
    os.makedirs(os.path.dirname(log_file), exist_ok=True)

    # Initialize options with defaults
    final_options = SbatchOptions(
        nodes=1,
        ntasks=1,
        job_name=full_id,
        output=log_file,
    )

    # Merge user-provided options (non-None values override defaults)
    user_data = asdict(options)
    for key, val in user_data.items():
        if key != "extra_options" and val is not None:
            setattr(final_options, key, val)
        elif key == "extra_options":
            final_options.extra_options.update(val)

    sbatch_args = final_options.to_sbatch_args()

    # --- Debug: Print SLURM Settings ---
    print("-" * 60)
    print(f"SLURM Configuration for Job: {full_id}")
    for arg in sbatch_args:
        print(f"  {arg}")
    print(f"  Command: {command}")
    print("-" * 60)

    # 6. Submit
    script_content = f"""#!/bin/bash
export SLURM_JOB_ID="{full_id}"
export AUTO_CLEANUP="{"true" if auto_cleanup else "false"}"
export HOST_SNAPSHOT_DIR="{snapshot_dir}"
export HOST_PROJECT_ROOT="{project_root}"

cleanup_worktree() {{
    if [ "$AUTO_CLEANUP" = "true" ]; then
        cd "$HOST_PROJECT_ROOT"
        git worktree remove -f "$HOST_SNAPSHOT_DIR" 2>/dev/null || true
        rm -rf "$HOST_SNAPSHOT_DIR"
    fi
}}
trap cleanup_worktree EXIT

cd "{snapshot_dir}"
eval "{command}"
"""
    try:
        proc = subprocess.Popen(["sbatch"] + sbatch_args, stdin=subprocess.PIPE)
        proc.communicate(input=script_content.encode())
        if proc.returncode != 0:
            raise subprocess.CalledProcessError(proc.returncode, "sbatch")
        print(f"Job submitted! Log: {log_file}")
    except Exception as e:
        print(f"Error: sbatch submission failed: {e}", file=sys.stderr)
        # Cleanup worktree on submission failure
        subprocess.call(
            ["git", "worktree", "remove", "-f", snapshot_dir],
            cwd=project_root,
            stderr=subprocess.DEVNULL,
        )
        if os.path.exists(snapshot_dir):
            subprocess.call(["rm", "-rf", snapshot_dir])
        sys.exit(1)


if __name__ == "__main__":
    run()
