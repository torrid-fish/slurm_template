#!/bin/bash
# Usage: ssubmit [OPTIONS] [SLURM_OPTIONS] '<command_or_script>'

# Get the directory where this script is located
SCRIPT_DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"
export SCRIPT_DIR

# Parse arguments using Python parser
{
    read -r AUTO_CLEANUP
    read -r SBATCH_ARGS_JSON
    read -r SCRIPT
} < <(python3 - "$@" << 'PYTHON_PARSER'
import sys
import json
import os
import shlex
sys.path.insert(0, os.environ.get('SCRIPT_DIR', ''))
from sbatch_parser import SbatchParser

# Parse command line arguments
parser = SbatchParser()

# Separate ssubmit-specific options from SLURM options
remaining_args = []
auto_cleanup = False

for arg in sys.argv[1:]:
    if arg == "--cleanup":
        auto_cleanup = True
    else:
        remaining_args.append(arg)

# Now parse SLURM options from remaining args
if remaining_args:
    options, command_args = parser.parse(remaining_args)
    
    if parser.errors:
        for error in parser.errors:
            print(f"Error: {error}", file=sys.stderr)
        sys.exit(1)
    
    sbatch_args = options.to_sbatch_args()
else:
    sbatch_args = []
    command_args = []

# Output: AUTO_CLEANUP, SBATCH_ARGS, SCRIPT
print(f"{auto_cleanup}")
print(json.dumps(sbatch_args))
if len(command_args) == 1:
    print(command_args[0])
else:
    print(shlex.join(command_args))
PYTHON_PARSER
)

# Check if script/command argument is provided
if [ -z "$SCRIPT" ]; then
    echo "Usage: ssubmit [OPTIONS] [SLURM_OPTIONS] '<command_or_script>'"
    echo ""
    echo "ssubmit options:"
    echo "  --cleanup           Automatically clean up worktree after job finishes (default: keep)"
    echo ""
    echo "Examples:"
    echo "  ssubmit 'python train.py'"
    echo "  ssubmit --cleanup -N 2 'python train.py'"
    echo "  ssubmit --cleanup --gres=gpu:h100:1 'python train.py'"
    echo ""
    echo "Common SLURM options:"
    echo "  -N NUM              Number of nodes"
    echo "  -n NUM              Number of tasks"
    echo "  -c NUM              CPUs per task"
    echo "  --time=D-HH:MM:SS   Time limit"
    echo "  --gres=TYPE:NUM     Generic resources (e.g., gpu:h100:1)"
    echo "  -p PARTITION        Partition name"
    exit 1
fi

# Convert JSON array to bash array
eval "PARSED_SBATCH_OPTS=($(echo "$SBATCH_ARGS_JSON" | python3 -c "import sys, json; opts = json.load(sys.stdin); print(' '.join(repr(x) for x in opts))"))"

# If script is a file, convert to absolute path
if [ -f "$SCRIPT" ]; then
    SCRIPT="$(cd "$(dirname "$SCRIPT")" && pwd)/$(basename "$SCRIPT")"
    # Quote it for safe eval
    SCRIPT="$(printf "%q" "$SCRIPT")"
fi

# Normalize AUTO_CLEANUP to boolean values used in the job
if [ "$AUTO_CLEANUP" = "True" ]; then
    AUTO_CLEANUP="true"
else
    AUTO_CLEANUP="false"
fi

if ! command -v git &> /dev/null; then
    echo "Git could not be found. Please install Git to use this script."
    exit 1
fi
# Get the absolute path of the current directory as the project root
HOST_PROJECT_ROOT="$(pwd)"

if [ -n "$(git status --porcelain)" ]; then
    echo "Dirty worktree detected. Please commit your changes first."
    echo "   (Git Worktree requires a clean commit to snapshot HEAD)"
    exit 1
fi

TIMESTAMP=$(date +%Y%m%d_%H%M%S)
GIT_HASH=$(git rev-parse --short HEAD 2>/dev/null || echo "nogit")
FULL_ID="${TIMESTAMP}_${GIT_HASH}"

HOST_SNAPSHOT_DIR="${HOME}/snapshots/${FULL_ID}"
mkdir -p "$HOST_SNAPSHOT_DIR"

# Setup cleanup trap for failed submissions
cleanup() {
    if [ $? -ne 0 ]; then
        echo "Cleaning up after error..."
        git worktree remove -f "$HOST_SNAPSHOT_DIR" 2>/dev/null || true
        rm -rf "$HOST_SNAPSHOT_DIR"
    fi
}
trap cleanup EXIT

echo "Creating code snapshot: $FULL_ID"
git worktree add --detach -f "$HOST_SNAPSHOT_DIR" HEAD > /dev/null

echo "Soft-linking data directories..."
DIRECTORIES=("data" "checkpoints" "output" "wandb" ".venv")
for DIR in "${DIRECTORIES[@]}"; do
    if [ -d "${HOST_PROJECT_ROOT}/${DIR}" ]; then
        mkdir -p "${HOST_SNAPSHOT_DIR}/${DIR}"
        ln -s "${HOST_PROJECT_ROOT}/${DIR}" "${HOST_SNAPSHOT_DIR}/${DIR}"
    fi
done

echo "Submitting job to SLURM..."
mkdir -p "${HOME}/log"

# Build sbatch command with default parameters and user-provided options
# Merge default options with parsed user options
SBATCH_OPTS=(
    "--nodes=1"
    "--ntasks=1"
    "--time=0-05:00:00"
    "--job-name=${FULL_ID}"
    "--output=${HOME}/log/${FULL_ID}.out"
)

# Append parsed user options (will override defaults)
SBATCH_OPTS+=("${PARSED_SBATCH_OPTS[@]}")

sbatch "${SBATCH_OPTS[@]}" << EOF
#!/bin/bash

export SLURM_JOB_ID="${FULL_ID}"
export AUTO_CLEANUP="${AUTO_CLEANUP}"
export HOST_SNAPSHOT_DIR="${HOST_SNAPSHOT_DIR}"
export HOST_PROJECT_ROOT="${HOST_PROJECT_ROOT}"

echo "   Job ID: \$SLURM_JOB_ID"
echo "   Job started on node: \$(hostname)"
echo "   Running script: $(basename "$SCRIPT")"
echo "   Snapshot Context: \$HOST_SNAPSHOT_DIR"

# Cleanup callback
cleanup_worktree() {
    if [ "\$AUTO_CLEANUP" = "true" ]; then
        echo "   Cleaning up worktree: \$HOST_SNAPSHOT_DIR"
        # Exit worktree and return to project root before removing
        cd "\$HOST_PROJECT_ROOT"
        git worktree remove -f "\$HOST_SNAPSHOT_DIR" 2>/dev/null || true
        rm -rf "\$HOST_SNAPSHOT_DIR"
        echo "   Cleanup completed"
    else
        echo "   Worktree snapshot kept at: \$HOST_SNAPSHOT_DIR"
        echo "   To manually clean up: cd \$HOST_PROJECT_ROOT && git worktree remove -f \$HOST_SNAPSHOT_DIR && rm -rf \$HOST_SNAPSHOT_DIR"
    fi
}

# Register cleanup callback on exit
trap cleanup_worktree EXIT

cd "$HOST_SNAPSHOT_DIR"
eval "$SCRIPT"

EOF

echo "Job submitted! Log will be saved to ${HOME}/log/${FULL_ID}.out"