#!/usr/bin/env python3
import sys
import os
import re
import json
import shlex
import subprocess
from dataclasses import dataclass, asdict, field
from datetime import datetime
from typing import Dict, List, Optional, Any, Tuple

# --- SLURM Parser Logic ---


@dataclass
class SbatchOptions:
    """Parsed SLURM sbatch options based on official documentation."""
    # Resource Allocation
    nodes: Optional[int] = None           # -N, --nodes
    ntasks: Optional[int] = None          # -n, --ntasks
    cpus_per_task: Optional[int] = None   # -c, --cpus-per-task
    partition: Optional[str] = None       # -p, --partition
    time: Optional[str] = None            # -t, --time
    gres: Optional[str] = None            # --gres

    # GPU Specific
    gpus: Optional[str] = None            # -G, --gpus
    gpus_per_node: Optional[str] = None   # --gpus-per-node
    gpus_per_task: Optional[str] = None   # --gpus-per-task
    mem_per_gpu: Optional[str] = None     # --mem-per-gpu

    # Memory
    mem: Optional[str] = None             # --mem
    mem_per_cpu: Optional[str] = None     # --mem-per-cpu

    # Job Naming & Output
    job_name: Optional[str] = None        # -J, --job-name
    output: Optional[str] = None          # -o, --output
    error: Optional[str] = None           # -e, --error
    chdir: Optional[str] = None           # -D, --chdir

    # Scheduling & Priority
    account: Optional[str] = None         # -A, --account
    begin: Optional[str] = None           # -b, --begin
    constraint: Optional[str] = None      # -C, --constraint
    dependency: Optional[str] = None      # -d, --dependency
    hold: Optional[bool] = None           # -H, --hold
    priority: Optional[str] = None        # --priority
    qos: Optional[str] = None             # -q, --qos
    reservation: Optional[str] = None     # --reservation

    # Node Selection
    nodelist: Optional[str] = None        # -w, --nodelist
    exclude: Optional[str] = None         # -x, --exclude
    ntasks_per_node: Optional[int] = None # --ntasks-per-node

    # Notifications
    mail_type: Optional[str] = None       # --mail-type
    mail_user: Optional[str] = None       # --mail-user

    # Advanced / Flags
    exclusive: Optional[bool] = None      # --exclusive
    overcommit: Optional[bool] = None     # -O, --overcommit
    oversubscribe: Optional[bool] = None  # -s, --oversubscribe
    array: Optional[str] = None           # -a, --array
    export: Optional[str] = None          # --export

    extra_options: Dict[str, Any] = field(default_factory=dict)

    def to_sbatch_args(self) -> List[str]:
        # Mapping for options that take values
        val_mapping = {
            "nodes": "--nodes", "ntasks": "--ntasks", "cpus_per_task": "--cpus-per-task",
            "partition": "--partition", "time": "--time", "gres": "--gres",
            "gpus": "--gpus", "gpus_per_node": "--gpus-per-node", "gpus_per_task": "--gpus-per-task",
            "mem_per_gpu": "--mem-per-gpu", "mem": "--mem", "mem_per_cpu": "--mem-per-cpu",
            "job_name": "--job-name", "output": "--output", "error": "--error",
            "chdir": "--chdir", "account": "--account", "begin": "--begin",
            "constraint": "--constraint", "dependency": "--dependency",
            "priority": "--priority", "qos": "--qos", "reservation": "--reservation",
            "nodelist": "--nodelist", "exclude": "--exclude", "ntasks_per_node": "--ntasks-per-node",
            "mail_type": "--mail-type", "mail_user": "--mail-user", "array": "--array", "export": "--export"
        }
        # Flags that don't take values
        flags = {"exclusive": "--exclusive", "hold": "--hold", "overcommit": "--overcommit", "oversubscribe": "--oversubscribe"}

        args = []
        for attr, flag in val_mapping.items():
            val = getattr(self, attr)
            if val is not None:
                args.append(f"{flag}={val}")

        for attr, flag in flags.items():
            if getattr(self, attr) is True:
                args.append(flag)

        for key, val in self.extra_options.items():
            if val is True:
                args.append(f"--{key.replace('_', '-')}")
            elif val is not False:
                args.append(f"--{key.replace('_', '-')}={val}")
        return args


class SbatchParser:
    OPTION_ALIASES = {
        "-N": "nodes", "--nodes": "nodes",
        "-n": "ntasks", "--ntasks": "ntasks",
        "-c": "cpus_per_task", "--cpus-per-task": "cpus_per_task",
        "-p": "partition", "--partition": "partition",
        "-t": "time", "--time": "time",
        "--gres": "gres",
        "-G": "gpus", "--gpus": "gpus",
        "--gpus-per-node": "gpus_per_node", "--gpus-per-task": "gpus_per_task",
        "--mem-per-gpu": "mem_per_gpu",
        "--mem": "mem", "--mem-per-cpu": "mem_per_cpu",
        "-J": "job_name", "--job-name": "job_name",
        "-o": "output", "--output": "output",
        "-e": "error", "--error": "error",
        "-D": "chdir", "--chdir": "chdir",
        "-A": "account", "--account": "account",
        "-b": "begin", "--begin": "begin",
        "-C": "constraint", "--constraint": "constraint",
        "-d": "dependency", "--dependency": "dependency",
        "-H": "hold", "--hold": "hold",
        "--priority": "priority",
        "-q": "qos", "--qos": "qos",
        "--reservation": "reservation",
        "-w": "nodelist", "--nodelist": "nodelist",
        "-x": "exclude", "--exclude": "exclude",
        "--ntasks-per-node": "ntasks_per_node",
        "--mail-type": "mail_type", "--mail-user": "mail_user",
        "--exclusive": "exclusive",
        "-O": "overcommit", "--overcommit": "overcommit",
        "-s": "oversubscribe", "--oversubscribe": "oversubscribe",
        "-a": "array", "--array": "array",
        "--export": "export"
    }

    FLAG_OPTIONS = {"hold", "exclusive", "overcommit", "oversubscribe"}

    def __init__(self):
        self.options = SbatchOptions()
        self.errors = []

    def parse(self, args: List[str]) -> Tuple[SbatchOptions, List[str]]:
        """
        Parse sbatch options from command line arguments.

        Args:
            args: Command line arguments (typically sys.argv[1:])

        Returns:
            Tuple of (SbatchOptions, remaining_args)
        """
        i = 0

        while i < len(args):
            arg = args[i]
            s_arg = arg.strip()

            # Skip empty arguments or literal backslashes often left by bad copy-pasting
            if not s_arg or s_arg == "\\":
                i += 1
                continue

            # If it's a non-option argument, everything from here on is the command
            if not s_arg.startswith("-"):
                # We return the original args list from this point to preserve spacing in command
                return self.options, args[i:]

            # Handle -- to stop parsing (standard convention)
            if s_arg == "--":
                return self.options, args[i + 1 :]

            # Handle -h or --help
            if s_arg in ("-h", "--help"):
                self._print_help()
                sys.exit(0)

            # Parse option
            i = self._parse_one(arg, args, i)

        return self.options, []

    def _parse_one(self, arg: str, args: List[str], index: int) -> int:
        arg = arg.strip()
        if "=" in arg:
            option, value = arg.split("=", 1)
            self._set(option, value)
            return index + 1

        canonical = self.OPTION_ALIASES.get(arg)
        if canonical:
            # Check if this option takes a value
            if canonical in self.FLAG_OPTIONS:
                self._set(arg, True)
                return index + 1

            if index + 1 < len(args):
                next_arg = args[index + 1].strip()
                if not next_arg.startswith("-") and next_arg != "\\":
                    self._set(arg, next_arg)
                    return index + 2

            self.errors.append(f"Option {arg} requires a value")
            return index + 1

        # Unknown option - store as extra
        option_name = arg.lstrip("-").replace("-", "_")
        self.options.extra_options[option_name] = True
        return index + 1

    def _set(self, opt: str, val: Any):
        canonical = self.OPTION_ALIASES.get(opt)
        if not canonical:
            self.options.extra_options[opt.lstrip("-").replace("-", "_")] = val
            return
        try:
            if canonical in ("nodes", "ntasks", "cpus_per_task", "ntasks_per_node"):
                setattr(self.options, canonical, int(val))
            elif canonical == "time":
                self._validate_time(val)
                setattr(self.options, canonical, val)
            elif canonical in ("mem", "mem_per_cpu"):
                self._validate_mem(val)
                setattr(self.options, canonical, val)
            else:
                setattr(self.options, canonical, val)
        except Exception as e:
            self.errors.append(f"Invalid value for {opt}: {e}")

    def _validate_time(self, s):
        if not (
            re.match(r"^\d+$", s)
            or re.match(r"^\d+-\d{1,2}:\d{2}:\d{2}$", s)
            or re.match(r"^\d{1,2}:\d{2}:\d{2}$", s)
        ):
            self.errors.append(f"Invalid time: {s}")

    def _validate_mem(self, s):
        if not re.match(r"^\d+[KMGT]?$", s, re.I):
            self.errors.append(f"Invalid memory: {s}")

    def _print_help(self):
        print("Usage: ssubmit [OPTIONS] [SLURM_OPTIONS] '<command>'")
        print("Options: --cleanup (Auto-remove worktree)")


# --- Main Logic ---


def run():
    # 1. Parse Args
    args = sys.argv[1:]
    auto_cleanup = "--cleanup" in args
    if auto_cleanup:
        args.remove("--cleanup")

    parser = SbatchParser()
    options, command_args = parser.parse(args)
    if parser.errors:
        for e in parser.errors:
            print(f"Error: {e}", file=sys.stderr)
        sys.exit(1)

    command = " ".join(command_args)
    if not command:
        print("Error: No command provided.")
        sys.exit(1)

    # Resolve SCRIPT path if it's a file
    script_path = command_args[0].strip() if command_args else ""
    if script_path and os.path.isfile(script_path):
        script_path = os.path.abspath(script_path)
        # Reconstruct command with stripped arguments to handle weird whitespace
        command = shlex.join([script_path] + [a.strip() for a in command_args[1:]])
    else:
        # If it's a general command string, use shlex.join on all args to be safe
        command = shlex.join([a.strip() for a in command_args])

    # 2. Git Check
    try:
        subprocess.check_call(
            ["git", "rev-parse", "--is-inside-work-tree"],
            stdout=subprocess.DEVNULL,
            stderr=subprocess.DEVNULL,
        )
    except:
        print("Error: Not a git repository.")
        sys.exit(1)

    if subprocess.check_output(["git", "status", "--porcelain"]):
        print("Error: Dirty worktree. Please commit changes first.")
        sys.exit(1)

    # 3. Setup IDs and Paths
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    git_hash = (
        subprocess.check_output(["git", "rev-parse", "--short", "HEAD"])
        .decode()
        .strip()
    )
    full_id = f"{timestamp}_{git_hash}"

    project_root = os.getcwd()
    snapshot_dir = os.path.expanduser(f"~/snapshots/{full_id}")
    os.makedirs(snapshot_dir, exist_ok=True)

    # 4. Snapshoting
    print(f"Creating snapshot: {full_id}")
    try:
        subprocess.check_call(
            ["git", "worktree", "add", "--detach", "-f", snapshot_dir, "HEAD"],
            stdout=subprocess.DEVNULL,
        )
    except Exception as e:
        print(f"Error creating worktree: {e}")
        sys.exit(1)

    # Soft-links
    for d in ["data", "checkpoints", "output", "wandb", ".venv"]:
        src = os.path.join(project_root, d)
        if os.path.isdir(src):
            dst = os.path.join(snapshot_dir, d)
            subprocess.call(["ln", "-s", src, dst])

    # 5. sbatch Options
    log_file = os.path.expanduser(f"~/log/{full_id}.out")
    os.makedirs(os.path.dirname(log_file), exist_ok=True)

    # Initialize options with defaults
    final_options = SbatchOptions(
        nodes=1,
        ntasks=1,
        job_name=full_id,
        output=log_file,
    )

    # Merge user-provided options (non-None values override defaults)
    user_data = asdict(options)
    for key, val in user_data.items():
        if key != "extra_options" and val is not None:
            setattr(final_options, key, val)
        elif key == "extra_options":
            final_options.extra_options.update(val)

    sbatch_args = final_options.to_sbatch_args()

    # --- Debug: Print SLURM Settings ---
    print("-" * 60)
    print(f"SLURM Configuration for Job: {full_id}")
    for arg in sbatch_args:
        print(f"  {arg}")
    print(f"  Command: {command}")
    print("-" * 60)

    # 6. Submit
    script_content = f"""#!/bin/bash
export FULL_ID="{full_id}"
export AUTO_CLEANUP="{"true" if auto_cleanup else "false"}"
export HOST_SNAPSHOT_DIR="{snapshot_dir}"
export HOST_PROJECT_ROOT="{project_root}"

cleanup_worktree() {{
    if [ "$AUTO_CLEANUP" = "true" ]; then
        cd "$HOST_PROJECT_ROOT"
        git worktree remove -f "$HOST_SNAPSHOT_DIR" 2>/dev/null || true
        rm -rf "$HOST_SNAPSHOT_DIR"
    fi
}}
trap cleanup_worktree EXIT

cd "{snapshot_dir}"
eval "{command}"
"""
    try:
        proc = subprocess.Popen(["sbatch"] + sbatch_args, stdin=subprocess.PIPE)
        proc.communicate(input=script_content.encode())
        if proc.returncode != 0:
            raise subprocess.CalledProcessError(proc.returncode, "sbatch")
        print(f"Job submitted! Log: {log_file}")
    except Exception as e:
        print(f"Error: sbatch submission failed: {e}", file=sys.stderr)
        # Cleanup worktree on submission failure
        subprocess.call(
            ["git", "worktree", "remove", "-f", snapshot_dir],
            cwd=project_root,
            stderr=subprocess.DEVNULL,
        )
        if os.path.exists(snapshot_dir):
            subprocess.call(["rm", "-rf", snapshot_dir])
        sys.exit(1)


if __name__ == "__main__":
    run()
